{"scenes":[{"name":"main","layers":[{"name":"obj","gameObjects":[{"name":"Ball","components":[{"type":"pos","x":60,"y":60},{"type":"sprite","id":"ball.png"},{"type":"rotate","angle":0},{"type":"origin","name":"center","custom":{"x":0,"y":0}},{"type":"tag","name":"ball"},{"type":"body","jumpForce":300,"maxVel":2400}]},{"name":"Floor 1","components":[{"type":"pos","x":20,"y":300},{"type":"rect","w":800,"h":10},{"type":"color","r":1,"g":1,"b":1,"a":1},{"type":"rotate","angle":0},{"type":"origin","name":"left","custom":{"x":0,"y":0}},{"type":"solid"},{"type":"tag","name":"floor"}]},{"name":"Floor 2","components":[{"type":"pos","x":1000,"y":300},{"type":"rect","w":800,"h":10},{"type":"color","r":1,"g":1,"b":1,"a":1},{"type":"origin","name":"left","custom":{"x":0,"y":0}},{"type":"solid"},{"type":"tag","name":"floor"}]},{"name":"Score","components":[{"type":"pos","x":600,"y":40},{"type":"text","text":"120","size":30,"width":0},{"type":"tag","name":"score"}]},{"name":"Camera","components":[{"type":"pos","x":512,"y":60},{"type":"tag","name":"camera"},{"type":"origin","name":"center","custom":{"x":0,"y":0}}]}]},{"name":"bg","gameObjects":[]},{"name":"ui","gameObjects":[]}],"actions":[{"type":"action","code":"const cameraOffsetX = 320;\nconst cameraSpeed = 0.975;\nconst boundaryY = 1250;\nconst ballRotateSpeed = 20;\nconst ballMoveSpeed = 300;\n\n// Calculates a score based on how far the ball has gotten on the X axis\nfunction calculateScore(xPos) {\n  return Math.floor(1.25 ** (1 + (xPos * 0.004)));\n}\n\n(k, ball) => {\n  // If the ball falls below the boundary, you have died ... go to the score screen;\n  if (ball.pos.y > boundaryY) {\n    k.ext.scores.submit(k.ext.data.score);\n    k.go('score');\n    return;\n  }\n\n  // Spin and move the ball\n  ball.angle -= (ballRotateSpeed * k.dt());\n  ball.move(k.vec2(ballMoveSpeed, 0));\n\n  // Smoothly adjust the camera such that the ball sits at the center left third of the screen\n  const cam = k.get('camera')[0];\n  if (cam) {\n    cam.pos.x = k.lerp(cam.pos.x, ball.pos.x + cameraOffsetX, cameraSpeed);\n    cam.pos.y = k.lerp(cam.pos.y, ball.pos.y, cameraSpeed);\n  }\n\n  // Update the latest game score and store it on window - we'll\n  // be using it later from the `score` scene, as well as here below.\n  k.ext.data.score = calculateScore(ball.pos.x);\n}","tag":"ball"},{"type":"keyDown","code":"const MAX_JUMP_FREQ = 0.85;\n\n(k) => {\n  k.every('ball', (ball) => {\n    if (!ball.jumpPrevented) {\n      ball.jump();\n      ball.jumpPrevented = true;\n    }\n  });\n}","keyName":"space"},{"type":"mouseDown","code":"const MAX_JUMP_FREQ = 0.85;\n\n(k) => {\n  k.every('ball', (ball) => {\n    if (!ball.jumpPrevented) {\n      ball.jump();\n      ball.jumpPrevented = true;\n    }\n  });\n}"},{"type":"collides","code":"(k, ball, floor) => {\n  ball.jumpPrevented = false;\n}","tag":"ball","otherTag":"floor"},{"type":"action","code":"(k, camera) => {\n  k.camPos(k.vec2(camera.pos.x, camera.pos.y));\n}","tag":"camera"},{"type":"action","code":"(k, scoreboard) => {\n  // Keep the scoreboard static on the top right of the camera frame\n  const cam = k.get('camera')[0];\n  if (!cam) {\n    return;\n  }\n  scoreboard.text = '' + k.ext.data.score;\n  scoreboard.pos.x = cam.pos.x + (window.innerWidth * 0.2);\n  scoreboard.pos.y = cam.pos.y - (window.innerHeight * 0.3);\n}","tag":"score"},{"type":"action","code":"// Spawn and destroy floor pieces as needed\n\nconst MAX_DISTANCE = 1600;\nconst SPAWN_DISTANCE = 100;\n\n(k) => {\n  const cam = k.get('camera')[0];\n  if (!cam) {\n    return;\n  }\n\n  let minX = null;\n  let maxX = null;\n  let floorMaxX = null;\n  let minDelta = null;\n  k.every('floor', (floor) => {\n    // Beyond some distance, we can just destroy the floor segment & move on\n    if (Math.abs(floor.pos.x - cam.pos.x) > MAX_DISTANCE) {\n      k.destroy(floor);\n      return;\n    }\n\n    // Find the minX and maxX for this floor piece, taking into account its width\n    const fMinX = floor.pos.x;\n    const fMaxX = floor.pos.x + floor.width;\n\n    // Update global minX and maxX, keeping a reference to the floor piece with max X\n    if (minX == null || minX > fMinX) {\n      minX = floor.pos.x;\n    }\n    if (maxX == null || maxX < fMaxX) {\n      maxX = floor.pos.x + floor.width;\n      floorMaxX = floor;\n    }\n\n    // Find the distance from the camera to the endpoints of this piece, and keep track\n    // of the minimum distance across all endpoints\n    const deltaMinX = Math.abs(fMinX - cam.pos.x);\n    const deltaMaxX = Math.abs(fMaxX - cam.pos.x);\n    const deltaMin = Math.min(deltaMinX, deltaMaxX);\n    minDelta = minDelta == null ? deltaMin : Math.min(minDelta, deltaMin);\n  });\n\n  // If the minimum distance across all endpoints is close to the camera, that\n  // means we have a platform close by, and don't need to spawn a new one\n  if (minDelta <= SPAWN_DISTANCE) {\n    return;\n  }\n\n  // Otherwise, we have no platforms nearby, and need to spawn one\n  const gapWidth = k.map(Math.random(), 0, 1, 120, 260);\n  const plankWidth = k.map(Math.random(), 0, 1, 100, 800);\n  k.add([\n    k.pos(maxX + gapWidth, floorMaxX.pos.y),\n    k.rect(plankWidth, floorMaxX.height),\n    k.color(floorMaxX.color.r, floorMaxX.color.g, floorMaxX.color.b),\n    k.origin('left'),\n    k.solid(),\n    'floor',\n  ]);\n\n  // Update the global maxX to account for the new floor piece\n  maxX += gapWidth + plankWidth;\n}"}]},{"name":"score","layers":[{"name":"obj","gameObjects":[{"name":"Background","components":[{"type":"pos","x":0,"y":0},{"type":"rect","w":4000,"h":4000},{"type":"color","r":1,"g":0,"b":0.01568627450980392,"a":1},{"type":"origin","name":"topleft","custom":{"x":0,"y":0}}]},{"name":"Score","components":[{"type":"pos","x":340,"y":240},{"type":"rect","w":40,"h":40},{"type":"color","r":0,"g":0,"b":0,"a":1},{"type":"text","text":"SCORE: 12345","size":25,"width":0},{"type":"tag","name":"finalscore"},{"type":"origin","name":"center","custom":{"x":0,"y":0}}]}]},{"name":"bg","gameObjects":[]},{"name":"ui","gameObjects":[]}],"actions":[{"type":"action","code":"(k, finalscore) => {\n  finalscore.pos.x = window.innerWidth * 0.5;\n  finalscore.pos.y = window.innerHeight * 0.5;\n  finalscore.text = 'SCORE: ' + k.ext.data.score;\n}","tag":"finalscore"},{"type":"mouseClick","code":"(k) => {\n  k.go('main');\n}"},{"type":"keyPress","code":"(k) => {\n  k.go('main');\n}","keyName":"space"}]}],"assets":[{"name":"ball.png","type":"sprite","skylink":"sia:AAC82HOGFUeFSlbwQ9iwOp2wfsavHg9VoIVbCDpXD2kpGw"}],"currentSceneName":"main"}